using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using Andy.Llm.Models;

namespace Andy.Cli.Services;

/// <summary>
/// Interprets LLM responses based on the model being used
/// </summary>
public interface IModelResponseInterpreter
{
    /// <summary>
    /// Extract tool calls from the model's response
    /// </summary>
    List<ModelToolCall> ExtractToolCalls(string response, string modelName, string provider);
    
    /// <summary>
    /// Format tool results for sending back to the model
    /// </summary>
    string FormatToolResults(List<ModelToolCall> toolCalls, List<string> results, string modelName, string provider);
    
    /// <summary>
    /// Check if the response contains fake tool results
    /// </summary>
    bool ContainsFakeToolResults(string response, string modelName);
    
    /// <summary>
    /// Clean response text for display
    /// </summary>
    string CleanResponseForDisplay(string response, string modelName);
}

public class ModelResponseInterpreter : IModelResponseInterpreter
{
    private readonly Dictionary<string, IModelInterpreter> _interpreters;
    
    public ModelResponseInterpreter()
    {
        _interpreters = new Dictionary<string, IModelInterpreter>(StringComparer.OrdinalIgnoreCase)
        {
            ["llama"] = new LlamaInterpreter(),
            ["qwen"] = new QwenInterpreter(),
            ["gpt"] = new GptInterpreter(),
            ["o1"] = new O1Interpreter(),  // OpenAI o1 models use thinking tags
            ["claude"] = new ClaudeInterpreter(),
            ["gemini"] = new GeminiInterpreter(),
            ["mistral"] = new MistralInterpreter(),
            ["deepseek"] = new DeepseekInterpreter(),
            ["gemma"] = new GemmaInterpreter(),
            ["mixtral"] = new MistralInterpreter(),
            ["phi"] = new PhiInterpreter(),
        };
    }
    
    public List<ModelToolCall> ExtractToolCalls(string response, string modelName, string provider)
    {
        var interpreter = GetInterpreter(modelName);
        return interpreter.ExtractToolCalls(response);
    }
    
    public string FormatToolResults(List<ModelToolCall> toolCalls, List<string> results, string modelName, string provider)
    {
        var interpreter = GetInterpreter(modelName);
        return interpreter.FormatToolResults(toolCalls, results);
    }
    
    public bool ContainsFakeToolResults(string response, string modelName)
    {
        var interpreter = GetInterpreter(modelName);
        return interpreter.ContainsFakeToolResults(response);
    }
    
    public string CleanResponseForDisplay(string response, string modelName)
    {
        var interpreter = GetInterpreter(modelName);
        return interpreter.CleanResponseForDisplay(response);
    }
    
    private IModelInterpreter GetInterpreter(string modelName)
    {
        modelName = modelName?.ToLowerInvariant() ?? "";
        
        // Try to match by prefix
        foreach (var kvp in _interpreters)
        {
            if (modelName.StartsWith(kvp.Key, StringComparison.OrdinalIgnoreCase))
            {
                return kvp.Value;
            }
        }
        
        // Default to GPT interpreter for unknown models
        return _interpreters["gpt"];
    }
}

/// <summary>
/// Base interface for model-specific interpreters
/// </summary>
internal interface IModelInterpreter
{
    List<ModelToolCall> ExtractToolCalls(string response);
    string FormatToolResults(List<ModelToolCall> toolCalls, List<string> results);
    bool ContainsFakeToolResults(string response);
    string CleanResponseForDisplay(string response);
}

/// <summary>
/// Base implementation with common functionality
/// </summary>
internal abstract class BaseModelInterpreter : IModelInterpreter
{
    public abstract List<ModelToolCall> ExtractToolCalls(string response);
    public abstract string FormatToolResults(List<ModelToolCall> toolCalls, List<string> results);
    
    public virtual bool ContainsFakeToolResults(string response)
    {
        return response.Contains("[Tool Results]", StringComparison.OrdinalIgnoreCase) ||
               response.Contains("Tool execution result", StringComparison.OrdinalIgnoreCase);
    }
    
    public virtual string CleanResponseForDisplay(string response)
    {
        // Remove special tags used by various models
        response = RemoveSpecialTags(response);
        
        // Remove common internal thoughts
        var patterns = new[]
        {
            @"I'll.*?tool\.",
            @"Let me.*?for you\.",
            @"I need to.*?\.",
            @"I'm going to.*?\.",
            @"Now I'll.*?\.",
        };
        
        foreach (var pattern in patterns)
        {
            response = Regex.Replace(response, pattern, "", RegexOptions.IgnoreCase);
        }
        
        return response.Trim();
    }
    
    /// <summary>
    /// Remove special tags like <thinking>, <reflection>, etc.
    /// </summary>
    protected virtual string RemoveSpecialTags(string response)
    {
        // Common thinking/reasoning tags used by various models
        var tagsToRemove = new[]
        {
            "thinking",      // Claude, some fine-tuned models
            "reflection",    // Some reasoning models
            "reasoning",     // Reasoning models
            "step",         // Step-by-step reasoning
            "plan",         // Planning tags
            "scratch",      // Scratchpad thinking
            "internal",     // Internal thoughts
            "thought",      // Thought process
            "analysis"      // Analysis tags
        };
        
        foreach (var tag in tagsToRemove)
        {
            // Remove both self-closing and paired tags
            response = Regex.Replace(response, $@"<{tag}[^>]*?/>", "", RegexOptions.IgnoreCase | RegexOptions.Singleline);
            response = Regex.Replace(response, $@"<{tag}[^>]*?>.*?</{tag}>", "", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        }
        
        return response;
    }
    
    protected ToolCall? ParseToolCallJson(string json)
    {
        try
        {
            var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;
            
            if (!root.TryGetProperty("tool", out var toolElement))
                return null;
                
            var toolId = toolElement.GetString();
            if (string.IsNullOrEmpty(toolId))
                return null;
                
            var parameters = new Dictionary<string, object?>();
            
            if (root.TryGetProperty("parameters", out var paramsElement))
            {
                foreach (var prop in paramsElement.EnumerateObject())
                {
                    parameters[prop.Name] = ParseJsonValue(prop.Value);
                }
            }
            
            return new ToolCall
            {
                ToolId = toolId,
                Parameters = parameters
            };
        }
        catch
        {
            return null;
        }
    }
    
    protected object? ParseJsonValue(JsonElement element)
    {
        return element.ValueKind switch
        {
            JsonValueKind.String => element.GetString(),
            JsonValueKind.Number => element.GetDouble(),
            JsonValueKind.True => true,
            JsonValueKind.False => false,
            JsonValueKind.Null => null,
            JsonValueKind.Array => element.EnumerateArray().Select(ParseJsonValue).ToList(),
            JsonValueKind.Object => element.EnumerateObject().ToDictionary(p => p.Name, p => ParseJsonValue(p.Value)),
            _ => element.ToString()
        };
    }
}

/// <summary>
/// Interpreter for Llama models
/// </summary>
internal class LlamaInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        var toolCalls = new List<ToolCall>();
        
        // Llama typically uses clean JSON format
        // Look for JSON blocks
        var jsonPattern = @"```json\s*(\{.*?\})\s*```";
        var matches = Regex.Matches(response, jsonPattern, RegexOptions.Singleline);
        
        foreach (Match match in matches)
        {
            var json = match.Groups[1].Value;
            var toolCall = ParseToolCallJson(json);
            if (toolCall != null)
            {
                toolCalls.Add(toolCall);
            }
        }
        
        // Also try direct JSON if no code blocks found
        if (toolCalls.Count == 0)
        {
            var directJsonPattern = @"\{[^{}]*""tool""\s*:\s*""[^""]+""[^{}]*\}";
            matches = Regex.Matches(response, directJsonPattern);
            
            foreach (Match match in matches)
            {
                var toolCall = ParseToolCallJson(match.Value);
                if (toolCall != null)
                {
                    toolCalls.Add(toolCall);
                }
            }
        }
        
        return toolCalls;
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Llama expects simple format
        var formatted = new List<string>();
        for (int i = 0; i < toolCalls.Count && i < results.Count; i++)
        {
            formatted.Add($"[Tool: {toolCalls[i].ToolId}]\n{results[i]}");
        }
        return string.Join("\n\n", formatted);
    }
}

/// <summary>
/// Interpreter for Qwen models
/// </summary>
internal class QwenInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        var toolCalls = new List<ToolCall>();
        
        // Qwen often outputs JSON with backticks but sometimes without proper markdown
        // First try to find JSON with backticks (with or without json marker)
        var patterns = new[]
        {
            @"`+json?\s*(\{.*?\})\s*`+",  // Backticks with optional json marker
            @"```\s*(\{.*?\})\s*```",      // Triple backticks without json marker
            @"(\{[^{}]*""tool""\s*:\s*""[^""]+""[^{}]*\})" // Direct JSON
        };
        
        foreach (var pattern in patterns)
        {
            var matches = Regex.Matches(response, pattern, RegexOptions.Singleline);
            foreach (Match match in matches)
            {
                var json = match.Groups[1].Value;
                var toolCall = ParseToolCallJson(json);
                if (toolCall != null)
                {
                    toolCalls.Add(toolCall);
                    break; // Usually Qwen outputs one tool call at a time
                }
            }
            
            if (toolCalls.Count > 0)
                break;
        }
        
        return toolCalls;
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Qwen prefers structured results
        var formatted = new List<string>();
        for (int i = 0; i < toolCalls.Count && i < results.Count; i++)
        {
            formatted.Add($"Tool Execution Result for {toolCalls[i].ToolId}:\n{results[i]}");
        }
        return string.Join("\n\n", formatted);
    }
    
    public override string CleanResponseForDisplay(string response)
    {
        // Remove the duplicated JSON that Qwen sometimes outputs
        response = Regex.Replace(response, @"`+json?\s*\{.*?\}\s*`+", "", RegexOptions.Singleline);
        response = Regex.Replace(response, @"```\s*\{.*?\}\s*```", "", RegexOptions.Singleline);
        
        return base.CleanResponseForDisplay(response);
    }
}

/// <summary>
/// Interpreter for GPT models
/// </summary>
internal class GptInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        var toolCalls = new List<ToolCall>();
        
        // GPT uses clean JSON in code blocks
        var jsonPattern = @"```json\s*(\{.*?\})\s*```";
        var matches = Regex.Matches(response, jsonPattern, RegexOptions.Singleline);
        
        foreach (Match match in matches)
        {
            var json = match.Groups[1].Value;
            var toolCall = ParseToolCallJson(json);
            if (toolCall != null)
            {
                toolCalls.Add(toolCall);
            }
        }
        
        return toolCalls;
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // GPT expects structured format
        var formatted = new List<string>();
        for (int i = 0; i < toolCalls.Count && i < results.Count; i++)
        {
            formatted.Add($"Tool: {toolCalls[i].ToolId}\nResult: {results[i]}");
        }
        return string.Join("\n\n", formatted);
    }
}

/// <summary>
/// Interpreter for Claude models
/// </summary>
internal class ClaudeInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        var toolCalls = new List<ToolCall>();
        
        // Claude uses <tool_use> tags or JSON blocks
        var toolUsePattern = @"<tool_use>\s*(\{.*?\})\s*</tool_use>";
        var matches = Regex.Matches(response, toolUsePattern, RegexOptions.Singleline);
        
        foreach (Match match in matches)
        {
            var json = match.Groups[1].Value;
            var toolCall = ParseToolCallJson(json);
            if (toolCall != null)
            {
                toolCalls.Add(toolCall);
            }
        }
        
        // Fallback to JSON blocks
        if (toolCalls.Count == 0)
        {
            var jsonPattern = @"```json\s*(\{.*?\})\s*```";
            matches = Regex.Matches(response, jsonPattern, RegexOptions.Singleline);
            
            foreach (Match match in matches)
            {
                var json = match.Groups[1].Value;
                var toolCall = ParseToolCallJson(json);
                if (toolCall != null)
                {
                    toolCalls.Add(toolCall);
                }
            }
        }
        
        return toolCalls;
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Claude expects tool_result format
        var formatted = new List<string>();
        for (int i = 0; i < toolCalls.Count && i < results.Count; i++)
        {
            formatted.Add($"<tool_result>\nTool: {toolCalls[i].ToolId}\n{results[i]}\n</tool_result>");
        }
        return string.Join("\n", formatted);
    }
}

/// <summary>
/// Interpreter for Gemini models
/// </summary>
internal class GeminiInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        // Similar to GPT
        return new GptInterpreter().ExtractToolCalls(response);
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Similar to GPT
        return new GptInterpreter().FormatToolResults(toolCalls, results);
    }
}

/// <summary>
/// Interpreter for Mistral/Mixtral models
/// </summary>
internal class MistralInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        // Similar to Llama
        return new LlamaInterpreter().ExtractToolCalls(response);
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Similar to Llama
        return new LlamaInterpreter().FormatToolResults(toolCalls, results);
    }
}

/// <summary>
/// Interpreter for Deepseek models
/// </summary>
internal class DeepseekInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        // Similar to Qwen for code models
        return new QwenInterpreter().ExtractToolCalls(response);
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Similar to Qwen
        return new QwenInterpreter().FormatToolResults(toolCalls, results);
    }
}

/// <summary>
/// Interpreter for Gemma models
/// </summary>
internal class GemmaInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        // Similar to Llama
        return new LlamaInterpreter().ExtractToolCalls(response);
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        // Similar to Llama
        return new LlamaInterpreter().FormatToolResults(toolCalls, results);
    }
}

/// <summary>
/// Interpreter for OpenAI o1 models (reasoning models)
/// </summary>
internal class O1Interpreter : GptInterpreter
{
    protected override string RemoveSpecialTags(string response)
    {
        // o1 models use <thinking> tags extensively
        // First remove thinking tags specifically
        response = Regex.Replace(response, @"<thinking>.*?</thinking>", "", RegexOptions.IgnoreCase | RegexOptions.Singleline);
        
        // Then apply base tag removal
        return base.RemoveSpecialTags(response);
    }
}

/// <summary>
/// Interpreter for Phi models
/// </summary>
internal class PhiInterpreter : BaseModelInterpreter
{
    public override List<ToolCall> ExtractToolCalls(string response)
    {
        // Phi models typically use clean JSON similar to GPT
        return new GptInterpreter().ExtractToolCalls(response);
    }
    
    public override string FormatToolResults(List<ToolCall> toolCalls, List<string> results)
    {
        return new GptInterpreter().FormatToolResults(toolCalls, results);
    }
}

public class ModelToolCall
{
    public string ToolId { get; set; } = "";
    public Dictionary<string, object?> Parameters { get; set; } = new();
}